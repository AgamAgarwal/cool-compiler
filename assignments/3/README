README file for Programming Assignment 3 (C++ edition)
======================================================

Your directory should now contain the following files:

 Makefile		  -> [course dir]/src/PA3/Makefile
 README
 cool.y
 bad.cl
 good.cl
 cool-tree.handcode.h
 cool-tree.cc		  -> [course dir]/src/PA3/cool-tree.cc
 cool-tree.aps		  -> [course dir]/src/PA3/cool-tree.aps
 dumptype.cc		  -> [course dir]/src/PA3/dumptype.cc
 handle_flags.c           -> [course dir]/src/PA3/handle_flags.cc
 parser-phase.cc	  -> [course dir]/src/PA3/parser-phase.cc
 stringtab.cc		  -> [course dir]/src/PA3/stringtab.cc
 tokens-lex.cc		  -> [course dir]/src/PA3/tokens-lex.cc
 tree.cc		  -> [course dir]/src/PA3/tree.cc
 utilities.cc		  -> [course dir]/src/PA3/utilities.cc
 *.d			  dependency files
 *.*			  other generated files

The include (.h) files for this assignment can be found in 
[course dir]/include/PA3

	The Makefile contains targets for compiling and running your
	program. DO NOT MODIFY.
    
	cool.y is the skeleton for the parser specification that you
	are to write. It already contains productions for the program
	and the classes. Use them as an example to write the remaining
	productions.  You should also read the bison documentation.
	This skeleton will compile and run as is, but it doesn't
	do much.

	good.cl, bad.cl test a few features of the grammar. You should
	add tests to ensure that good.cl exercises every legal
	construction of the grammar and that bad.cl exercises as many
	different parsing errors as you can squeeze into one file.

	cool-tree.aps contains the definitions for the tree language
	which you use to construct the abstract syntax tree (AST).
	From this file, cool-tree.h and cool-tree.cc are automatically 
        generated by a utility that compiles the specification into
        C++ functions for producing and consuming the tree nodes.
        This file is provided for your reference.  DO NOT MODIFY.

        tree.{cc|h} contain definitions used by the tree package.
        cool-tree.handcode.h is the handwritten extension to
        cool-tree.h.  If you read cool-tree.h and cool-tree.cc, you will
        note that there are "hooks" for extending the classes
        declarations.  Extending and modifying the tree package is
        discussed in the "Cool Tour", but you do not need to (and should
        not) modify the tree package for this assignment.

	tokens-lex.cc is a lexer capable of reading a token stream from
	console in the format produced by the lexer phase. DO NOT
	MODIFY.

        parser-phase.cc contains a driver to test the parser. DO NOT
        MODIFY.

	dumptype.cc prints the AST out in a form readable by the
	semant phase of the compiler. DO NOT MODIFY.

	handle_flags.cc implements routines for parsing command line
        flags. DO NOT MODIFY.

        The rest of the files are created as byproducts of `bison'.
        `cool-parse.cc' is the generated C++ file containing the
        parser.

	Files not discussed are covered in the README for PA2.

Instructions
------------

	To compile your parser program type:

	% make parser

	This produces an executable named "parser" which is standalone
	phase of the Cool compiler.  It requires lexer, semant, and cgen
	to do anything useful.

	To test your parser on a file 'foo.cl' type

	% myparser foo.cl

	myparser is a shell script that "glues" together lexer and
	parser using pipes.

	To run your parser on the files good.cl and bad.cl type:

	% make dotest

	To run the (provided) lexer and your parser on a file called test.cl type:

	% ./lexer test.cl | ./parser

	If you think your parser is correct and behaves like
	the one we wrote, you may want to run a COOL compiler using
	your parser:

	% mycoolc foo.cl

	To overwrite the default lexical analyzer with yours, replace 
	lexer (which is a symbolic link to the "official" lexer) with
        your lexer from PA2.


        Instructions for turning in the assignment will be posted on the
        course web page.

        GOOD LUCK!
========================================================================

Write-up
--------

The objective of this assignment was to create a parser for COOL. The 
parser was developed using Bison. The following are some of the design 
decisions.

Precedence and Associativity
	The order of precedence (increasing) of the non-terminals is as 
	follows:
	%nonassoc IN
    %right ASSIGN
    %nonassoc NOT
    %nonassoc '<' LE '='
    %left '+' '-'
    %left '*' '/'
    %nonassoc ISVOID
    %nonassoc '~'
    %left '@'
    %left '.'
	
	These precendence rules were required to eliminate 117 shift/reduce 
	conflicts arising from the various grammar rules.
	Assignment operator is right associative to allow constructs like
	(x<-y<-5).
	Binary arithmetic operators are left associative. '@' and
	'.' is left associative to allow chained dispatches like:
	x.initialize().increment().print().

Lists
	The grammar of COOL allows certain lists, such as formals, actuals, 
	features, classes and expressions in blocks. These lists have no 
	fixed size (Kleene closure), so these had to be implemented using
	recursive rules. Left recursion was used because Bison prefers left
	recursion.

Let statement
	The let statement was implemented in a way that it allows only a 
	single object declaration (+optional initialization) for the given 
	block. Multiple declarations like 
	let x:Int, y:Int IN { (* code here *) }
	are not inherently parsed as it is. A simple trick converts such
	declarations into multiple nested "let" expressions. Like, the above
	is parsed as equivalent to:
	let x:Int IN
		let y:Int IN
			{ (* code here *) }

Optional initialization
	Some of the constructs included an optional initialization, such as
	the declaration of variables in let statement. One way of 
	implementing this is by using two productions for every non-terminal
	has an optional initialization. Another way is using a new non-
	terminal which can expand to "empty" or to the initialization 
	expression. The second way seems to be better, but it has an 
	inherent flaw. Bison, by default, sets the line number of a non-
	terminal to that of the first terminal of the matched production
	rule. This fails for empty rules, which give a garbage value as the
	line number as there is no "first" terminal as such. Thus we used
	the first method.

Error handling
	The following errors were caught.
	class_list
		If there is an error in a class definition, the parser skips the
		current class, and continues parsing from the next class.
	feature_list
		If there is an error in a feature definition, the parser skips 
		the	current feature, and continues parsing from the next feature
		of the class.
	expr_list
		If there is an error in any of the expressions in an expression 
		block, the parser skips those expressions but parsers the others.
	let_list
		If there is an error in the declaration part of a let construct,
		the parser skips the whole let the statement (including the "IN"
		part). However, if there is an error in the "IN" part, it is
		handled in one of the above cases.

AST generation
	The AST generation was done using the functions available in 
	cool-tree.cc. There was a function defined for each kind of 
	construct. For any rule matched, its value is assigned using '$$'.
	For example,
	expr: expr '+' expr
	{	$$=plus($1, $3); }
	where $1 and $3 refer to first and second operands respectively.
